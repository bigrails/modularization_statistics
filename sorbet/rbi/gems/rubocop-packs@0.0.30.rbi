# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop-packs` gem.
# Please instead update this file by running `bin/tapioca gem rubocop-packs`.

# source://rubocop-packs//lib/rubocop/packs/private/configuration.rb#4
module RuboCop; end

# source://rubocop-packs//lib/rubocop/cop/packwerk_lite/private.rb#4
module RuboCop::Cop; end

# source://rubocop-packs//lib/rubocop/cop/packs/root_namespace_is_pack_name/desired_zeitwerk_api.rb#5
module RuboCop::Cop::Packs; end

# This is a private class that represents API that we would prefer to be available somehow in Zeitwerk.
# However, the boundaries between systems (packwerk/zeitwerk, rubocop/zeitwerk) are poor in this class, so
# that would need to be separated prior to proposing any API changes in zeitwerk.
#
# source://rubocop-packs//lib/rubocop/cop/packs/root_namespace_is_pack_name/desired_zeitwerk_api.rb#12
class RuboCop::Cop::Packs::RootNamespaceIsPackName::DesiredZeitwerkApi
  # For now, this API includes `package_for_path`
  # If this were truly zeitwerk API, it wouldn't include any mention of packs and it would likely not need the package at all
  # Since it could get the actual namespace without knowing anything about packs.
  # However, we would need to pass to it the desired namespace based on the pack name for it to be able to suggest
  # a desired filepath.
  # Likely this means that our own cop should determine the desired namespace and pass that in
  # and this can determine actual namespace and how to get to expected.
  #
  # source://rubocop-packs//lib/rubocop/cop/packs/root_namespace_is_pack_name/desired_zeitwerk_api.rb#32
  sig do
    params(
      relative_filename: ::String,
      package_for_path: ::ParsePackwerk::Package
    ).returns(T.nilable(::RuboCop::Cop::Packs::RootNamespaceIsPackName::DesiredZeitwerkApi::NamespaceContext))
  end
  def for_file(relative_filename, package_for_path); end

  # source://rubocop-packs//lib/rubocop/cop/packs/root_namespace_is_pack_name/desired_zeitwerk_api.rb#86
  sig { params(pack: ::ParsePackwerk::Package).returns(::String) }
  def get_pack_based_namespace(pack); end

  private

  # source://rubocop-packs//lib/rubocop/cop/packs/root_namespace_is_pack_name/desired_zeitwerk_api.rb#103
  sig { params(remaining_file_path: ::String, package_name: ::String).returns(::String) }
  def get_actual_namespace(remaining_file_path, package_name); end

  # source://rubocop-packs//lib/rubocop/cop/packs/root_namespace_is_pack_name/desired_zeitwerk_api.rb#98
  sig { params(pack: ::ParsePackwerk::Package).returns(::String) }
  def get_package_last_name(pack); end

  # source://rubocop-packs//lib/rubocop/cop/packs/root_namespace_is_pack_name/desired_zeitwerk_api.rb#93
  sig { returns(::Pathname) }
  def root_pathname; end
end

# source://rubocop-packs//lib/rubocop/cop/packs/root_namespace_is_pack_name/desired_zeitwerk_api.rb#15
class RuboCop::Cop::Packs::RootNamespaceIsPackName::DesiredZeitwerkApi::NamespaceContext < ::T::Struct
  const :current_fully_qualified_constant, ::String
  const :current_namespace, ::String
  const :expected_filepath, ::String
  const :expected_namespace, ::String

  class << self
    # source://sorbet-runtime/0.5.9924/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://rubocop-packs//lib/rubocop/cop/packwerk_lite/private.rb#5
module RuboCop::Cop::PackwerkLite; end

# This is a private class that represents API that we would prefer to be available somehow in Zeitwerk.
# However, the boundaries between systems (packwerk/zeitwerk, rubocop/zeitwerk) are poor in this class, so
# that would need to be separated prior to proposing any API changes in zeitwerk.
#
# source://rubocop-packs//lib/rubocop/cop/packwerk_lite/constant_resolver.rb#11
class RuboCop::Cop::PackwerkLite::ConstantResolver; end

# source://rubocop-packs//lib/rubocop/packs/private/configuration.rb#5
module RuboCop::Packs
  class << self
    # source://rubocop-packs//lib/rubocop/packs.rb#135
    sig { void }
    def bust_cache!; end

    # source://rubocop-packs//lib/rubocop/packs.rb#146
    sig { returns(::RuboCop::Packs::Private::Configuration) }
    def config; end

    # @yield [config]
    #
    # source://rubocop-packs//lib/rubocop/packs.rb#141
    sig { params(blk: T.proc.params(arg0: ::RuboCop::Packs::Private::Configuration).void).void }
    def configure(&blk); end

    # We can remove this function once package_protections is fully deprecated
    #
    # source://rubocop-packs//lib/rubocop/packs.rb#154
    sig { params(rule: ::String).returns(T::Set[::String]) }
    def exclude_for_rule(rule); end

    # source://rubocop-packs//lib/rubocop/packs.rb#99
    sig { params(root_pathname: ::String).returns(::String) }
    def pack_based_rubocop_config(root_pathname: T.unsafe(nil)); end

    # Ideally, this is API that is available to us via `rubocop` itself.
    # That is: the ability to preserve the location of `.rubocop_todo.yml` files and associate
    # exclusions with the closest ancestor `.rubocop_todo.yml`
    #
    # source://rubocop-packs//lib/rubocop/packs.rb#30
    sig { params(packs: T::Array[::ParsePackwerk::Package], files: T::Array[::String]).void }
    def regenerate_todo(packs: T.unsafe(nil), files: T.unsafe(nil)); end

    # Ideally, this is API that is available to us via `rubocop` itself.
    # That is: the ability to preserve the location of `.rubocop_todo.yml` files and associate
    # exclusions with the closest ancestor `.rubocop_todo.yml`
    #
    # source://rubocop-packs//lib/rubocop/packs.rb#78
    sig { params(packs: T::Array[::ParsePackwerk::Package]).void }
    def set_default_rubocop_yml(packs:); end

    # Note: when we add per-pack `.rubocop.yml` files, we'll want to add some validations here
    # to restrict what cops are permitted to be configured in those files.
    # We might also want further (configurable?) constraints *requiring* that the "permitted pack level cops" be specified explicitly.
    #
    # source://rubocop-packs//lib/rubocop/packs.rb#164
    sig { returns(T::Array[::String]) }
    def validate; end
  end
end

# source://rubocop-packs//lib/rubocop/packs.rb#20
RuboCop::Packs::CONFIG = T.let(T.unsafe(nil), Hash)

# source://rubocop-packs//lib/rubocop/packs.rb#19
RuboCop::Packs::CONFIG_DEFAULT = T.let(T.unsafe(nil), Pathname)

# Because RuboCop doesn't yet support plugins, we have to monkey patch in a
# bit of our configuration.
#
# source://rubocop-packs//lib/rubocop/packs/inject.rb#10
module RuboCop::Packs::Inject
  class << self
    # source://rubocop-packs//lib/rubocop/packs/inject.rb#14
    sig { void }
    def defaults!; end
  end
end

# source://rubocop-packs//lib/rubocop/packs.rb#16
RuboCop::Packs::PACK_LEVEL_RUBOCOP_TODO_YML = T.let(T.unsafe(nil), String)

# Pack-level rubocop and rubocop_todo YML files are named differently because they are not integrated
# into rubocop in the standard way. For example, we could call these the standard `.rubocop.yml` and
# `.rubocop_todo.yml`. However, this introduces a number of path relativity issues (https://docs.rubocop.org/rubocop/configuration.html#path-relativity)
# that make this approach not possible. Therefore, for pack level rubocops, we name them in a way that mirrors packwerk `package_todo.yml` files
# for consistency and to ensure that thes are not read by rubocop except via the ERB templating mechanism.
#
# source://rubocop-packs//lib/rubocop/packs.rb#15
RuboCop::Packs::PACK_LEVEL_RUBOCOP_YML = T.let(T.unsafe(nil), String)

# source://rubocop-packs//lib/rubocop/packs.rb#18
RuboCop::Packs::PROJECT_ROOT = T.let(T.unsafe(nil), Pathname)

# source://rubocop-packs//lib/rubocop/packs/private/configuration.rb#6
module RuboCop::Packs::Private
  class << self
    # source://rubocop-packs//lib/rubocop/packs/private.rb#13
    sig { void }
    def bust_cache!; end

    # source://rubocop-packs//lib/rubocop/packs/private.rb#107
    sig { params(rule: ::String).returns(T::Set[::String]) }
    def exclude_for_rule(rule); end

    # source://rubocop-packs//lib/rubocop/packs/private.rb#152
    sig { params(args: T.untyped).void }
    def execute_rubocop(args); end

    # source://rubocop-packs//lib/rubocop/packs/private.rb#19
    sig { void }
    def load_client_configuration; end

    # source://rubocop-packs//lib/rubocop/packs/private.rb#157
    sig do
      params(
        paths: T::Array[::String],
        cop_names: T::Array[::String]
      ).returns(T::Array[::RuboCop::Packs::Private::Offense])
    end
    def offenses_for(paths:, cop_names:); end

    # source://rubocop-packs//lib/rubocop/packs/private.rb#29
    sig { returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
    def rubocop_todo_ymls; end

    # source://rubocop-packs//lib/rubocop/packs/private.rb#126
    sig { params(package: ::ParsePackwerk::Package).returns(T::Array[::String]) }
    def validate_failure_mode_strict(package); end

    # source://rubocop-packs//lib/rubocop/packs/private.rb#40
    sig { params(package: ::ParsePackwerk::Package).returns(T::Array[::String]) }
    def validate_rubocop_todo_yml(package); end

    # source://rubocop-packs//lib/rubocop/packs/private.rb#75
    sig { params(package: ::ParsePackwerk::Package).returns(T::Array[::String]) }
    def validate_rubocop_yml(package); end
  end
end

# source://rubocop-packs//lib/rubocop/packs/private/configuration.rb#7
class RuboCop::Packs::Private::Configuration
  # source://rubocop-packs//lib/rubocop/packs/private/configuration.rb#20
  sig { void }
  def initialize; end

  # source://rubocop-packs//lib/rubocop/packs/private/configuration.rb#27
  sig { void }
  def bust_cache!; end

  # source://rubocop-packs//lib/rubocop/packs/private/configuration.rb#17
  sig { returns(T::Array[::String]) }
  def globally_permitted_namespaces; end

  # @return [Array<String>]
  #
  # source://rubocop-packs//lib/rubocop/packs/private/configuration.rb#17
  def globally_permitted_namespaces=(_arg0); end

  # source://rubocop-packs//lib/rubocop/packs/private/configuration.rb#11
  sig { returns(T::Array[::String]) }
  def permitted_pack_level_cops; end

  # @return [Array<String>]
  #
  # source://rubocop-packs//lib/rubocop/packs/private/configuration.rb#11
  def permitted_pack_level_cops=(_arg0); end

  # source://rubocop-packs//lib/rubocop/packs/private/configuration.rb#14
  sig { returns(T::Array[::String]) }
  def required_pack_level_cops; end

  # @return [Array<String>]
  #
  # source://rubocop-packs//lib/rubocop/packs/private/configuration.rb#14
  def required_pack_level_cops=(_arg0); end
end

# source://rubocop-packs//lib/rubocop/packs/private/offense.rb#6
class RuboCop::Packs::Private::Offense < ::T::Struct
  const :cop_name, ::String
  const :filepath, ::String

  # source://rubocop-packs//lib/rubocop/packs/private/offense.rb#13
  sig { returns(::ParsePackwerk::Package) }
  def pack; end

  class << self
    # source://sorbet-runtime/0.5.9924/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# See docs/packwerk_lite.md
#
# source://rubocop-packs//lib/rubocop/packwerk_lite.rb#11
module RuboCop::PackwerkLite; end

# source://rubocop-packs//lib/rubocop/packwerk_lite.rb#12
class RuboCop::PackwerkLite::Error < ::StandardError; end
